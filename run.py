#!/usr/bin/env python3
"""
LabelWatch AI – Day 1–2 MVP runner.

1. Fetches DailyMed RSS (last 7 days).
2. Filters by config watchlist.
3. Optionally fetches SPL history for each match.
4. Writes a simple impact report (text/markdown) for validation outreach.
"""

import argparse
import sys
from pathlib import Path

# Allow running from repo root
sys.path.insert(0, str(Path(__file__).resolve().parent))

from config import WATCHLIST_DRUGS
from scrapers.dailymed import (
    fetch_rss_updates,
    filter_updates_by_watchlist,
    fetch_spl_history,
    get_label_changes,
    LabelUpdate,
)

# Sample data for --demo (no network needed)
DEMO_UPDATES = [
    LabelUpdate(
        title="VIAGRA (sildenafil citrate) tablet, film coated [PFIZER LABORATORIES DIV PFIZER INC]",
        link="https://dailymed.nlm.nih.gov/dailymed/lookup.cfm?setid=0b0be196-0c62-461c-94f4-9a35339b4501&version=32",
        setid="0b0be196-0c62-461c-94f4-9a35339b4501",
        version=32,
        updated_date="Fri, 13 Feb 2026 00:00:00 EST",
        pub_date="Fri, 13 Feb 2026 00:00:00 EST",
    ),
    LabelUpdate(
        title="TRAMADOL HYDROCHLORIDE tablet, film coated [Unichem Pharmaceuticals (USA), Inc.]",
        link="https://dailymed.nlm.nih.gov/dailymed/lookup.cfm?setid=007bf37f-0e46-426a-ac8c-be63d4b7414c&version=24",
        setid="007bf37f-0e46-426a-ac8c-be63d4b7414c",
        version=24,
        updated_date="Fri, 13 Feb 2026 00:00:00 EST",
        pub_date="Fri, 13 Feb 2026 00:00:00 EST",
    ),
    LabelUpdate(
        title="ESCITALOPRAM tablet, film coated [Torrent Pharmaceuticals Limited]",
        link="https://dailymed.nlm.nih.gov/dailymed/lookup.cfm?setid=068bb338-23f3-4278-958b-c34b40456024&version=28",
        setid="068bb338-23f3-4278-958b-c34b40456024",
        version=28,
        updated_date="Fri, 13 Feb 2026 00:00:00 EST",
        pub_date="Fri, 13 Feb 2026 00:00:00 EST",
    ),
]


def build_impact_report_md(
    matches: list[LabelUpdate],
    fetch_history: bool = True,
    change_texts: list[str] | None = None,
    fda_validation: list[tuple[str, int | None]] | None = None,
) -> str:
    """Build impact report as markdown string. If change_texts is provided, show 'What changed' inline. If fda_validation, show FDA cross-check per entry."""
    lines = [
        "# LabelWatch AI – Label Updates (Last 7 Days)",
        "",
        "## Watchlist matches",
        "",
    ]
    for i, u in enumerate(matches):
        version_info = ""
        if fetch_history:
            history = fetch_spl_history(u.setid)
            if history:
                data = history.get("data", {})
                hist_entries = data.get("history", [])
                version_info = f" (SPL versions: {len(hist_entries)} total; current: {u.version})"
        lines.extend([
            f"### {u.title}",
            "",
            f"- **Updated:** {u.updated_date or u.pub_date}",
            f"- **Set ID:** `{u.setid}` | **Version:** {u.version}{version_info}",
            f"- **Link:** {u.link}",
            "",
        ])
        if fda_validation is not None and i < len(fda_validation):
            msg, _ = fda_validation[i]
            lines.append(f"- **FDA cross-check:** {msg}")
            lines.append("")
        if change_texts is not None and i < len(change_texts) and change_texts[i].strip():
            lines.append("**What changed in this label:**")
            lines.append("")
            lines.append(change_texts[i].strip())
            lines.append("")
        elif change_texts is not None and i < len(change_texts):
            lines.append("*No change summary for this label (e.g. no previous version or API unavailable).*")
            lines.append("")
    lines.append("---")
    if fda_validation:
        lines.append("")
        lines.append("*FDA cross-check: openFDA drug label API (api.fda.gov). FDA updates weekly; DailyMed (NLM) may sync on a different schedule. 'In sync' = same effective date; 'X days ahead' = one source has a newer date.*")
    lines.append(f"*Generated by LabelWatch AI. {len(matches)} watchlist match(es).*")
    return "\n".join(lines)


def build_impact_report(
    matches: list[LabelUpdate],
    output_path: Path,
    fetch_history: bool = True,
) -> None:
    """Write a simple impact report to file (for Day 3 manual PDFs / outreach)."""
    md = build_impact_report_md(matches, fetch_history=fetch_history)
    output_path.write_text(md, encoding="utf-8")
    print(f"Wrote impact report: {output_path}")


def generate_report(
    demo: bool = False,
    fetch_history: bool = False,
    watchlist: list[str] | None = None,
) -> tuple[list[LabelUpdate], str]:
    """Fetch data, build report; returns (matches, markdown_string)."""
    drugs = watchlist if watchlist is not None else WATCHLIST_DRUGS
    if demo:
        matches = DEMO_UPDATES
    else:
        updates = fetch_rss_updates()
        matches = filter_updates_by_watchlist(updates, drugs)
    md = build_impact_report_md(matches, fetch_history=fetch_history)
    return matches, md


def generate_report_with_changes(
    demo: bool = False,
    watchlist: list[str] | None = None,
) -> tuple[list[LabelUpdate], str, list[str]]:
    """
    Fetch data, build report, and compute "what changed" per label (current vs previous SPL).
    Returns (matches, markdown_string with changes inline, list of change_summary per match).
    """
    drugs = watchlist if watchlist is not None else WATCHLIST_DRUGS
    if demo:
        matches = DEMO_UPDATES
        change_texts = [
            "Demo mode: use live data (uncheck 'Use demo data') with 'Include what changed' to see real label diffs (Warnings, Dosage, etc.)."
            for _ in matches
        ]
    else:
        updates = fetch_rss_updates()
        matches = filter_updates_by_watchlist(updates, drugs)
        change_texts = []
        for u in matches:
            change_texts.append(get_label_changes(u.setid, u.version))
    md = build_impact_report_md(matches, fetch_history=False, change_texts=change_texts)
    return matches, md, change_texts


def main() -> None:
    p = argparse.ArgumentParser(description="LabelWatch AI – fetch DailyMed updates and write impact report.")
    p.add_argument("--no-history", action="store_true", help="Skip SPL history API calls (faster).")
    p.add_argument("--demo", action="store_true", help="Use sample data so you can see the report without the live RSS.")
    args = p.parse_args()

    if args.demo:
        print("Demo mode: using sample label updates (no network).")
        matches = DEMO_UPDATES
    else:
        print("Fetching DailyMed RSS (last 7 days)...")
        updates = fetch_rss_updates()
        print(f"Total updates in feed: {len(updates)}")
        matches = filter_updates_by_watchlist(updates, WATCHLIST_DRUGS)
        print(f"Watchlist matches: {len(matches)}")

    for u in matches:
        print(f"  - {u.title[:70]}...") if len(u.title) > 70 else print(f"  - {u.title}")

    out_dir = Path(__file__).resolve().parent / "output"
    out_dir.mkdir(exist_ok=True)
    report_path = out_dir / "impact_report.md"
    build_impact_report(matches, report_path, fetch_history=not args.no_history and not args.demo)

    print("\nDone. Use output/impact_report.md for Day 3 outreach (or convert to PDF).")


if __name__ == "__main__":
    main()
